const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, stripe-signature",
};

export default {
  async fetch(request, env) {
    // Preflight para CORS
    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders });
    }

    const url = new URL(request.url);

    // Ruta para webhook Stripe
    if (url.pathname === "/webhook" && request.method === "POST") {
      return handleStripeWebhook(request, env);
    }

    // Ruta para iniciar pago
    if (request.method === "POST") {
      return handlePaymentInit(request, env);
    }

    return new Response("Método no permitido", { status: 405 });
  },

  // Evento programado para limpieza automática (Cron Trigger)
  async scheduled(event, env, ctx) {
    await handleCleanup(env);
  },
};

// Función para iniciar pago
async function handlePaymentInit(request, env) {
  try {
    const data = await request.json();
    const db = env.DB;

    // Guardar en DB con estado pendiente
    const now = new Date().toISOString();

    const result = await db
      .prepare(
        `INSERT INTO registros (tipo, nombre, apellido1, apellido2, email, dni, provincia, monto, cuota, estado, created_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pendiente', ?)`
      )
      .bind(
        data.tipo,
        data.nombre,
        data.apellido1,
        data.apellido2,
        data.email,
        data.dni,
        data.provincia,
        data.monto,
        data.cuota || null,
        now
      )
      .run();

    // Obtener ID insertado
    const registroId = result.meta.last_row_id;

    let body;
    if (data.tipo === "suscripcion") {
      let priceId = "";
      switch (data.cuota) {
        case 5:
          priceId = "price_1RslIQ2U6h8FikYkiLxar2yJ";
          break;
        case 10:
          priceId = "price_1Rt9el2U6h8FikYkMlZJWYbn";
          break;
        case 15:
          priceId = "price_1Rt9f32U6h8FikYko8s4czqR";
          break;
        case 50:
          priceId = "price_1Rt9fO2U6h8FikYkV754husH";
          break;
        default:
          return jsonResponse({ error: "Cuota no válida" }, 400);
      }
      body =
        "payment_method_types[]=card" +
        "&mode=subscription" +
        "&line_items[0][price]=" + priceId +
        "&line_items[0][quantity]=1" +
        "&success_url=" + encodeURIComponent("https://elantipolitico.pages.dev/pagos") +
        "&cancel_url=" + encodeURIComponent("https://elantipolitico.pages.dev/afiliacion") +
        `&metadata[registroId]=${registroId}`;
    } else if (data.tipo === "donacion") {
      const MAX_DONACION = 50000;
      const monto = Math.min(data.monto, MAX_DONACION);
      const params = new URLSearchParams();

      params.append("payment_method_types[]", "card");
      params.append("mode", "payment");
      params.append("line_items[0][price_data][currency]", "eur");
      params.append("line_items[0][price_data][product_data][name]", "Donación");
      params.append("line_items[0][price_data][unit_amount]", Math.round(monto * 100).toString());
      params.append("line_items[0][quantity]", "1");
      params.append("success_url", "https://elantipolitico.pages.dev/pagos");
      params.append("cancel_url", "https://elantipolitico.pages.dev/donaciones");
      params.append("metadata[registroId]", registroId.toString());

      body = params.toString();
    } else {
      return jsonResponse({ error: "Tipo no válido" }, 400);
    }

    const stripeSecretKey = env.STRIPE_SECRET_KEY;
    const response = await fetch("https://api.stripe.com/v1/checkout/sessions", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${stripeSecretKey}`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body,
    });

    const resultStripe = await response.json();
    if (!response.ok) {
      return jsonResponse({ error: resultStripe.error.message }, 400);
    }

    return jsonResponse({ id: resultStripe.id });
  } catch (err) {
    return jsonResponse({ error: err.message }, 500);
  }
}

// Función para manejar webhook Stripe
async function handleStripeWebhook(request, env) {
  try {
    const payload = await request.text();
    const signatureHeader = request.headers.get("stripe-signature");
    if (!signatureHeader) return new Response("Falta stripe-signature", { status: 400 });

    const webhookSecret = env.STRIPE_WEBHOOK_SECRET;
    const isValid = await verifyStripeSignature(payload, signatureHeader, webhookSecret);
    if (!isValid) return new Response("Firma inválida", { status: 400 });

    const event = JSON.parse(payload);

    if (event.type === "checkout.session.completed") {
      const session = event.data.object;
      const registroId = session.metadata?.registroId;
      if (registroId) {
        await env.DB
          .prepare("UPDATE registros SET estado = 'confirmado' WHERE id = ?")
          .bind(registroId)
          .run();
      }
    }

    return new Response("OK", { status: 200, headers: corsHeaders });
  } catch (err) {
    return new Response("Error: " + err.message, { status: 500, headers: corsHeaders });
  }
}

// Función para borrar registros pendientes creados hace más de 12 horas
async function handleCleanup(env) {
  try {
    const db = env.DB;

    const deleteResult = await db.prepare(
      `DELETE FROM registros
       WHERE estado = 'pendiente'
         AND replace(substr(created_at, 1, 19), 'T', ' ') <= datetime('now', '-12 hours')`
    ).run();

    console.log(`Registros borrados: ${deleteResult.changes || 0}`);
  } catch (err) {
    console.error('Error en limpieza automática:', err);
  }
}

// Verificar firma Stripe
async function verifyStripeSignature(payload, signatureHeader, secret) {
  const elements = signatureHeader.split(",");
  const timestampElement = elements.find((e) => e.startsWith("t="));
  const v1Element = elements.find((e) => e.startsWith("v1="));
  if (!timestampElement || !v1Element) return false;

  const timestamp = timestampElement.split("=")[1];
  const signature = v1Element.split("=")[1];
  const message = `${timestamp}.${payload}`;

  const key = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["verify"]
  );

  const signatureBuffer = hexToBuffer(signature);
  return crypto.subtle.verify("HMAC", key, signatureBuffer, new TextEncoder().encode(message));
}

function hexToBuffer(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes.buffer;
}

function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { ...corsHeaders, "Content-Type": "application/json" },
  });
}
